
// New and improved animation module. Uses JSON files generated by Aseprite (pixel art program) to generate animations.
// If you don't use Aseprite, that's totally fine! Simply hand over whatever you made and I will export appropriately! :)
// Made by your project lead, yours truly, Remy L.

// Do note that:
// - Animation go hand in hand with the State Machine pattern. Characters have state machines that look at anims to determine their behaviours.
// - Animations also contain hitbox and hurtbox data, which are drawn in Aseprite and included in the JSON data. This is only for size and position; the details (like, if it's a punch or a kick) are handled elsewhere (dunno where yet haha)
// - There is no Spritesheet class; it's all in the JSON data as well

// As will all the modules in Arcaninjadroid, don't hesitate to contact me if you need help or want a walkthrough of the implementation! :)

function Animation (parent, image, data, config) {

    this.isActive = true; //left public for simplicity of get/set

    var parent = parent;

    var currentFrameNum = 0; // index of the frame to be drawn
    var timeCounter = 0; //keeps track of time passage and updates current frame

    if (!config) {config = {};}
    var loop = config.loop || false;

    var holdLastFrame = config.holdLastFrame || false; // if true, we will need to change player state with something other than the end of the anim (like a ground check)
    var holding = false;

    if (data) {

        var frameCount = data.frames.length;
        var nextTimeStamp = data.frames[currentFrameNum].duration/1000; //original duration in MS
    }

    else {
        var frameCount = 1;
        holdLastFrame = true;
        holding = true;
    }

    if (frameCount === 1){ holdLastFrame = true};

    // Save clip values and update only when we change frames
    var clipStartX = 0;
    var clipStartY = 0;
    
    if (data) {
        var clipWidth = data.frames[currentFrameNum].frame.w;
        var clipHeight = data.frames[currentFrameNum].frame.h;
    }

    var hitboxes = [];
    //console.log(hitboxes)
    //hitboxes[4] = [1,2];
    var hurtboxes = [];


    // Call this every frame, updates the current frame of animation
    this.update = function () {

        if (this.isActive === false || holding) {
            //console.log("hold")
            return;
        }

        timeCounter += dt; //in seconds just like everything else that includes dt

        // Check if our anim is over, and either reset it or terminate it if needed
        if (timeCounter > nextTimeStamp) {

            //Switch to next frame
            if (currentFrameNum < frameCount-1) {
                
                currentFrameNum++;
                timeCounter = 0;
                nextTimeStamp = data.frames[currentFrameNum].duration/1000;

                clipStartX = data.frames[currentFrameNum].frame.x;
                clipStartY = data.frames[currentFrameNum].frame.y;
                
            }

            // Handle animation end...
            else {
                if (loop){                   
                    this.loop();
                }
                else if (holdLastFrame) {
                    holding = true;
                }
                else {
                    this.isActive = false;
                }
            }
        }
    }

    this.draw = function () {

        if (this.isActive === false) {
            console.log("Tried to draw inactive animation.");
            return;
        }
        if (data) {
            var clipWidth = data.frames[currentFrameNum].frame.w;
            var clipHeight = data.frames[currentFrameNum].frame.h;

        } else {
            var clipWidth = image.width; //image.width or height cannot be read at init, since image isn't loaded and the values are 0! (hence why their are read here and not above)
            var clipHeight = image.height;
        }       
        var x = parent.x;
        var y = parent.y;

        canvasContext.drawImage(image,
                                clipStartX,clipStartY, clipWidth, clipHeight, 
                                x-clipWidth/2,y-clipHeight/2, clipWidth, clipHeight);
    }

    this.drawColliders = function (x,y) {
        if (this.isActive === false) {
            return;
        }

        for (var j = 0, k = hitboxes[currentFrameNum].length; j < k; j++){
            hitboxes[currentFrameNum][j].draw();
        }
        for (var j = 0, k = hurtboxes[currentFrameNum].length; j < k; j++){
            hurtboxes[currentFrameNum][j].draw();

        }

    }

    this.loop = function () {
        currentFrameNum = 0;
        timeCounter = 0;
        if (data){
            nextTimeStamp = data.frames[currentFrameNum].duration/1000;
            clipStartX = data.frames[currentFrameNum].frame.x;
            clipStartY = data.frames[currentFrameNum].frame.y;
        }

        this.isActive = true;
        holding = false;
    }

    this.getcurrentFrameNumNumber = function () {
        return currentFrameNum;
    }


    this.loadColliders = function () {

        if (!data) {return;} //to change
        var slices = data.meta.slices;

        for (var i = 0, l = frameCount; i < l; i++) {

            hitboxes[i] = [];
            hurtboxes[i] = [];
        }

        for (var i = 0, l = slices.length; i < l; i++) {
            for (var j = 0, k = slices[i].keys.length; j < k; j++){

                var sliceKey = slices[i].keys[j];
                var frame = slices[i].keys[j].frame;

                var config = {
                    offsetX: sliceKey.bounds.x - (data.frames[frame].sourceSize.w - sliceKey.bounds.w)/2, // try drawing this as an exercise haha
                    offsetY: sliceKey.bounds.y - (data.frames[frame].sourceSize.h - sliceKey.bounds.h)/2,
                    isTrigger: true,
                    color: slices[i].color}

                if (slices[i].name === "Hit"){
                    hitboxes[frame].push(new RectCollider(parent, sliceKey.bounds.w,sliceKey.bounds.h, config));

                } else if (slices[i].name === "Hurt"){
                    hurtboxes[frame].push(new RectCollider(parent, sliceKey.bounds.w,sliceKey.bounds.h, config));
                }

            }

        }
    }
    
    this.getHitboxes = function () {
        return hitboxes[currentFrameNum];
    }
    this.getHurtboxes = function () {
        return hurtboxes[currentFrameNum];
    }

    this.loadColliders();
}

/*
//IMPORTANT: sprite sheets cannot have incomplete rows, but they can have "full" sheets of any size
function SpriteSheet (image, numRows, numCols) {

    var image = image; //the image variable, NOT the path string!
    
    var numRows = numRows ? numRows : 1;
    var numCols = numCols ? numCols : 1;

    if (numRows == 0) { numRow = 1;} //safety checks to avoid divide by 0
    if (numCols == 0) { numCols = 1;}


    this.getImage = function () {
        return image;
    }

    this.getNumRows = function () {
        return numRows;
    }
    this.getNumCols = function () {
        return numCols;
    }

    //Note: having an "Images" module means that (as of now) images have 0 width, 0 height on program startup, because they are not loaded yet
    // As such, we cannot save the width and heights in fields on startup... and we need getters
    this.getSpriteWidth = function () {
        return image.width / numCols;
    }

    this.getSpriteHeight = function () {
        return image.height / numRows;
    }
}
*/
/////////////////      Example      ///////////////////////
/*
var mySheet = new SpriteSheet (Images.getImage("myImage3rows2cols"), 3,2);

var myAnimConfig = {
    fps : 15,
    loop: true
}
var myAnim = new Animation (mySheet, myAnimConfig);
*/