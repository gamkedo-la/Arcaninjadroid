
// New and improved animation module. Uses JSON files generated by Aseprite (pixel art program) to generate animations.
// If you don't use Aseprite, that's totally fine! Simply hand over whatever you made and I will export appropriately! :)
// Made by your project lead, yours truly, Remy L.

// Do note that:
// - Animation go hand in hand with the State Machine pattern. Characters have state machines that look at anims to determine their behaviours.
// - Animations also contain hitbox and hurtbox data, which are drawn in Aseprite and included in the JSON data. This is only for size and position; the details (like, if it's a punch or a kick) are handled elsewhere (dunno where yet haha)
// - There is no Spritesheet class; it's all in the JSON data as well

// As will all the modules in Arcaninjadroid, don't hesitate to contact me if you need help or want a walkthrough of the implementation! :)

function Animation (image, data, config) {

    this.isActive = true; //left public for simplicity of get/set

    var currentFrameNum = 0; // index of the frame to be drawn
    var timeCounter = 0; //keeps track of time passage and updates current frame

    if (!config) {config = {};}
    var loop = config.loop || false;

    var holdLastFrame = config.holdLastFrame || false; // if true, we will need to change player state with something other than the end of the anim (like a ground check)
    var holding = false;

    if (data) {

        var frameCount = data.frames.length;
        var nextTimeStamp = data.frames[currentFrameNum].duration/1000; //original duration in MS
    }

    else {
        var frameCount = 1;
        holdLastFrame = true;
        holding = true;
    }

    if (frameCount === 1){ holdLastFrame = true};

    // Save clip values and update only when we change frames
    var clipStartX = 0;
    var clipStartY = 0;
    
    if (data) {
        var clipWidth = data.frames[currentFrameNum].frame.w;
        var clipHeight = data.frames[currentFrameNum].frame.h;
    }

    //console.log(loop)

    // Call this every frame, updates the current frame of animation
    this.update = function () {

        if (this.isActive === false || holding) {
            //console.log("hold")
            return;
        }

        timeCounter += dt; //in seconds just like everything else that includes dt

        // Check if our anim is over, and either reset it or terminate it if needed
        if (timeCounter > nextTimeStamp) {

            //Switch to next frame
            if (currentFrameNum < frameCount-1) {
                
                currentFrameNum++;
                timeCounter = 0;
                nextTimeStamp = data.frames[currentFrameNum].duration/1000;

                clipStartX = data.frames[currentFrameNum].frame.x;
                clipStartY = data.frames[currentFrameNum].frame.y;
                
            }

            // Handle animation end...
            else {
                if (loop){                   
                    this.loop();
                }
                else if (holdLastFrame) {
                    holding = true;
                }
                else {
                    this.isActive = false;
                }
            }
        }
    }

    this.draw = function (x,y) {

        if (this.isActive === false) {
            console.log("Tried to draw inactive animation.");
            return;
        }

        if (data) {
            var clipWidth = data.frames[currentFrameNum].frame.w;
            var clipHeight = data.frames[currentFrameNum].frame.h;

        } else {
            var clipWidth = image.width; //image.width or height cannot be read at init, since image isn't loaded and the values are 0! (hence why their are read here and not above)
            var clipHeight = image.height;
        }       


        canvasContext.drawImage(image,
                                clipStartX,clipStartY, clipWidth, clipHeight, 
                                x-clipWidth/2,y-clipHeight/2, clipWidth, clipHeight);
    }

    this.loop = function () {
        currentFrameNum = 0;
        timeCounter = 0;
        if (data){
            nextTimeStamp = data.frames[currentFrameNum].duration/1000;
            clipStartX = data.frames[currentFrameNum].frame.x;
            clipStartY = data.frames[currentFrameNum].frame.y;
        }

        this.isActive = true;
        holding = false;
    }

    this.getcurrentFrameNumNumber = function () {
        return currentFrameNum;
    }

    // TODO
    this.getHitboxes = function () {

    }

    this.getHurtboxes = function () {
        
    }

}

/*
//IMPORTANT: sprite sheets cannot have incomplete rows, but they can have "full" sheets of any size
function SpriteSheet (image, numRows, numCols) {

    var image = image; //the image variable, NOT the path string!
    
    var numRows = numRows ? numRows : 1;
    var numCols = numCols ? numCols : 1;

    if (numRows == 0) { numRow = 1;} //safety checks to avoid divide by 0
    if (numCols == 0) { numCols = 1;}


    this.getImage = function () {
        return image;
    }

    this.getNumRows = function () {
        return numRows;
    }
    this.getNumCols = function () {
        return numCols;
    }

    //Note: having an "Images" module means that (as of now) images have 0 width, 0 height on program startup, because they are not loaded yet
    // As such, we cannot save the width and heights in fields on startup... and we need getters
    this.getSpriteWidth = function () {
        return image.width / numCols;
    }

    this.getSpriteHeight = function () {
        return image.height / numRows;
    }
}
*/
/////////////////      Example      ///////////////////////
/*
var mySheet = new SpriteSheet (Images.getImage("myImage3rows2cols"), 3,2);

var myAnimConfig = {
    fps : 15,
    loop: true
}
var myAnim = new Animation (mySheet, myAnimConfig);
*/